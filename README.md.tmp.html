<meta charset="UTF-8">
<h1>üçØ Appunti SQL</h1>

<p>Il software che utilizziamo a scuola √®:</p>

<p>
<img height="32" width="32" src="https://cdn.simpleicons.org/xampp/orange" alt="XAMPP"/>
</p>

<p><code>‚ÑπÔ∏è</code> <a href="https://en.wikipedia.org/wiki/XAMPP">Scopri di pi√π</a> <code>‚≠êÔ∏è</code> <a href="https://github.com/plumkewe/scuola/tree/main/Attivita-svolta/2023/SQL">Esercizi svolti</a> <code>üåé</code> <a href="https://www.w3schools.com/sql/default.asp">W3S</a> <code>üë©‚Äçüè´</code> <a href="file:///Users/lybomyr/Desktop/GitHub/appunti-sql/presentazione/">Presentazioni</a></p>

<blockquote>
  <p><strong>Note</strong>\
Verr√† aggiornato solo quando avr√≤ voglia!</p>
</blockquote>

<h3>Da fare</h3>

<ul>
<li>[x] ~Migliorare la sezione contenuti~</li>
<li>[x] ~Tradurre le spiegazini~</li>
<li>[x] ~Evidenziare parole importanti nel testo~</li>
<li>[ ] Migliorare la dimostrazione</li>
</ul>

<p><br></p>

<h2>Contenuti</h2>

<ul>
<li><a href="#definizioni">Definizioni</a>
<ul>
<li><a href="#database">Database</a>
<ul>
<li><a href="#dbms">DBMS</a></li>
<li><a href="#relazionali">Relazionali</a></li>
<li><a href="#nosql">NoSQL</a></li>
</ul></li>
<li><a href="#sql">SQL</a>
<ul>
<li><a href="#query">Query</a>
<ul>
<li><a href="#query-clauses">Query clauses</a></li>
</ul></li>
<li><a href="#primary-key">Primary key</a></li>
<li><a href="#foreign-key">Foreign key</a></li>
<li><a href="#DDL">DDL</a></li>
<li><a href="#DML">DML</a></li>
<li><a href="#DCL">DCL</a></li>
</ul></li>
</ul></li>
<li><a href="#consigli">Consigli</a>
<ul>
<li><a href="#case-when-pi√π-esplicito">CASE WHEN pi√π esplicito</a></li>
<li><a href="#struttura-pi√π-chiara">Struttura pi√π chiara</a></li>
<li><a href="#espressioni-aritmetiche">Espressioni aritmetiche</a></li>
<li><a href="#alias-significativi">Alias significativi</a></li>
</ul></li>
<li><a href="#data-manipulation-language">Data Manipulation Language (DML)</a>
<ul>
<li><a href="#selezione-dei-dati">Selezione dei dati</a>
<ul>
<li><a href="#select-statement">SELECT statement</a>
<ul>
<li><a href="#tutte-colonne">Tutte colonne</a></li>
<li><a href="#colonne-specifiche">Colonne specifiche</a></li>
<li><a href="#colonne-con-alias">Colonne con alias</a></li>
<li><a href="#colonne-con-espressioni-aritmetiche">Colonne con espressioni aritmetiche</a></li>
<li><a href="#seleziona-dati-univoci">Seleziona dati univoci</a></li>
</ul></li>
<li><a href="#filtraggio-dei-dati">Filtraggio dei dati</a>
<ul>
<li><a href="#corrispondenze-parziali-o-pattern">Corrispondenze parziali o pattern</a></li>
<li><a href="#valore-specifico-in-una-colonna">Valore specifico in una colonna</a></li>
<li><a href="#valore-null-o-non-null">Valore NULL o non NULL</a></li>
<li><a href="#filtrare-utilizzando-una-lista-dei-valori">Filtrare utilizzando una lista dei valori</a></li>
</ul></li>
<li><a href="#operatori-di-confronto">Operatori di confronto</a>
<ul>
<li><a href="#ugualianza">Ugualianza</a></li>
<li><a href="#disugualianza">Disugualianza</a></li>
<li><a href="#maggiore-di">Maggiore di</a></li>
<li><a href="#maggiore-o-uguale-di">Maggiore o uguale di</a></li>
<li><a href="#minore">Minore</a></li>
<li><a href="#minore-o-uguale-di">Minore o uguale di</a></li>
</ul></li>
<li><a href="#operatori-logici">Operatori logici</a>
<ul>
<li><a href="#and">AND</a></li>
<li><a href="#or">OR</a></li>
<li><a href="#and-e-or">AND e OR</a></li>
<li><a href="#not">NOT</a></li>
</ul></li>
<li><a href="#ordinamento-dei-risultati">Ordinamento dei risultati</a></li>
<li><a href="#limitazione-dei-risultati">Limitazione dei risultati</a></li>
</ul></li>
<li><a href="#operatori-di-aggregazione">Operatori di aggregazione</a>
<ul>
<li><a href="#sommare-i-valori">Sommare i valori</a></li>
<li><a href="#calcolare-la-media">Calcolare la media</a></li>
<li><a href="#contare">Contare</a></li>
<li><a href="#valore-massimo">Valore massimo</a></li>
<li><a href="#valore-minimo">Valore minimo</a></li>
<li><a href="#arrotondamento">Arrotondamento</a></li>
</ul></li>
<li><a href="#join">JOIN delle tabelle</a>
<ul>
<li><a href="#inner-join">INNER JOIN</a></li>
<li><a href="#left-join">LEFT JOIN</a></li>
<li><a href="#right-join">RIGHT JOIN</a></li>
<li><a href="#full-join">FULL JOIN</a></li>
<li><a href="#unione-implicita">Unione implicita</a></li>
</ul></li>
<li>Subquery
<ul>
<li>Che restituiscono un valore
<ul>
<li>MAX</li>
<li>AVG</li>
</ul></li>
<li>Subquery che restituiscono pi√π valori 
<ul>
<li>IN </li>
<li>NOT IN</li>
<li>ANY</li>
<li>ALL</li>
<li>EXIT</li>
<li>NOT EXIT</li>
</ul></li>
<li>Query correlate</li>
<li>subquery nella FROM</li>
</ul></li>
</ul></li>
</ul>

<!-- - [Modifica dei dati](#modifica-dei-dati)
    - [INSERT INTO](#insert-into)
    - [UPDATE](#update)
    - [DELETE](#delete)
    - [Transazioni](#transazioni) -->

<h2>Definizioni</h2>

<h3>Database</h3>

<p>Un database √® un insieme organizzato di dati. Pu√≤ essere tutto, da un semplice elenco di contatti telefonici fino a un intero inventario di prodotti per un'azienda.</p>

<h4>DBMS</h4>

<p>Un DBMS √® un software che gestisce i database. Esempi comuni sono MySQL, PostgreSQL, MongoDB e SQLite.</p>

<h4>Relazionali</h4>

<p>Un database relazionale √® un tipo di database che organizza i dati in <strong>tabelle</strong> con <strong>righe</strong> e <strong>colonne</strong>, molto simile a come i dati sono organizzati in un <strong>foglio di calcolo</strong>. Ogni <strong>riga</strong> rappresenta un <strong>record</strong> distinto e ogni <strong>colonna</strong> rappresenta un <strong>campo</strong> di quel <strong>record</strong>. Le <strong>tabelle</strong> possono essere collegate tra loro attraverso <strong>chiavi primarie</strong> e <strong>chiavi esterne</strong>, permettendo di creare <strong>relazioni</strong> tra i dati. Questo modello di database √® molto comune e largamente utilizzato in molte applicazioni. Esempi di <strong>DBMS relazionali</strong> includono <strong>MySQL</strong>, <strong>PostgreSQL</strong> e <strong>SQLite</strong>.</p>

<h4>NoSQL</h4>

<p>I <strong>database NoSQL</strong>, o "non solo SQL", sono un tipo di database che non seguono il <strong>modello relazionale</strong> standard. Sono progettati per essere <strong>altamente scalabili</strong> e per gestire <strong>grandi quantit√† di dati distribuiti</strong> su molteplici macchine. I <strong>database NoSQL</strong> non richiedono uno <strong>schema fisso</strong>, il che significa che i dati possono essere inseriti nel database senza dover prima definire la <strong>struttura della tabella</strong>. Questo li rende molto <strong>flessibili</strong> e adatti per lavorare con <strong>dati non strutturati</strong> o <strong>semi-strutturati</strong>. Esistono diversi tipi di <strong>database NoSQL</strong>, tra cui <strong>database di documenti</strong> (come <strong>MongoDB</strong>), <strong>database di chiave-valore</strong> (come <strong>Redis</strong>), <strong>database di colonne</strong> (come <strong>Cassandra</strong>) e <strong>database di grafi</strong> (come <strong>Neo4j</strong>)..</p>

<h4>DDL</h4>

<p>Comandi utilizzati per definire o modificare la struttura di un database o di una tabella. Esempi di comandi DDL includono <code>CREATE</code>, <code>ALTER</code> e <code>DROP</code>.</p>

<h4>DML</h4>

<p>Comandi utilizzati per manipolare i dati all'interno delle tabelle di un database. Esempi di comandi DML includono <code>SELECT</code>, <code>INSERT</code>, <code>UPDATE</code> e <code>DELETE</code>.</p>

<h4>DCL</h4>

<p>Comandi utilizzati per controllare l'accesso ai dati all'interno del database. Esempi di comandi DCL includono <code>GRANT</code> e <code>REVOKE</code>, che sono utilizzati per gestire i diritti e i privilegi degli utenti.</p>

<p><br></p>

<h3>SQL</h3>

<p>SQL √® un linguaggio di programmazione utilizzato per comunicare con e manipolare i database.</p>

<p>Con SQL si possono fare seguenti operazioni:</p>

<table>
<tbody>
  <tr>
    <td><b>DDL</b></td>
    <td>Creazione di tabelle</td>
  </tr>
  <tr>
    <td rowspan="3"><b>DML</b></td>
    <td>Aggiornamento dei dati</td>
  </tr>
  <tr>
    <td>Cancellazione dei dati</td>
  </tr>
  <tr>
    <td>Interrogazione dei dati</td>
  </tr>
  <tr>
    <td><b>DCL</b></td>
    <td>Gestione dei permessi di accesso</td>
  </tr>
</tbody>
</table>

<h4>Query</h4>

<p>Una query SQL √® un modo di comunicare con il <strong>database</strong> per ottenere le <strong>informazioni</strong> di cui hai bisogno o per effettuare <strong>**modifiche</strong> nei dati. Detto meglio: Una query √® una richiesta di dati da un database.</p>

<h5>Query clauses</h5>

<table>
    <tbody>
        <tr>
            <td><code>select</code></td>
            <td>Determines which columns to include in the query's result set</td>
        </tr>
        <tr>
            <td><code>from</code></td>
            <td>Identifies the tables from which to retrive data and how the tables should be joined</td>
        </tr>
        <tr>
            <td><code>where</code></td>
            <td>Filters out unwanted data</td>
        </tr>
        <tr>
            <td><code>group by</code></td>
            <td>Used to group rows together by common column values</td>
        </tr>
        <tr>
            <td><code>having</code></td>
            <td>Filters out unwanted groups</td>
        </tr>
        <tr>
            <td><code>order by</code></td>
            <td>Sorts the rows of the final result set by one or more columns</td>
        </tr>
    </tbody>
</table>

<h4>Primary key</h4>

<p>Una chiave primaria √® un campo unico in una tabella che pu√≤ identificare ogni riga.</p>

<h4>Foreign key</h4>

<p>Una chiave esterna √® un campo in una tabella che fa riferimento alla chiave primaria di un'altra tabella.</p>

<p><br>
<br></p>

<h2>Consigli</h2>

<h3>CASE WHEN pi√π esplicito</h3>

<p>Rendi il blocco CASE WHEN pi√π esplicito, elencando tutte le condizioni in modo chiaro.
<code>sql
SELECT
    Nome,
    CASE
        WHEN Et√† &lt; 18 THEN 'Minorenne'
        WHEN Et√† &gt;= 18 AND Et√† &lt; 65 THEN 'Adulto'
        ELSE 'Anziano'
    END AS FasciaEt√†
FROM
    Persone;
</code></p>

<h3>Struttura pi√π chiara</h3>

<p>Indenta il codice in modo che le clausole siano chiaramente visibili e allinea i termini per una migliore leggibilit√†.
<code>sql
SELECT
    Colonna1,
    Colonna2
FROM
    Tabella
WHERE
    Condizione = 'Valore';
</code></p>

<h3>Espressioni aritmetiche</h3>

<p>Evita ambiguit√† nelle operazioni aritmetiche utilizzando le parentesi per definire la precedenza degli operatori.
<code>sql
SELECT 
    (Colonna1 + Colonna2) * Colonna3 AS Risultato
FROM
    Tabella;
</code></p>

<h3>Alias significativi</h3>

<p>Usa alias significativi per rendere chiare le colonne calcolate.
<code>sql
SELECT
    Nome,
    (Punteggio1 + Punteggio2) / 2 AS MediaPunteggio
FROM
    Studenti;
</code></p>

<p><br>
<br></p>

<h1>Data Manipulation Language</h1>

<p>La <strong>Data Manipulation Language (DML)</strong> √® una parte del linguaggio SQL (<em>Structured Query Language</em>) utilizzata per manipolare i dati all'interno di un database relazionale.</p>

<p>La <strong>DML</strong> consente di eseguire le seguenti azioni principali:</p>

<ul>
<li><em>Inserimento di dati (INSERT)</em>: La DML permette di aggiungere nuovi dati a una tabella esistente del database.</li>
<li><em>Aggiornamento dei dati (UPDATE)</em>: √à possibile utilizzare la DML per modificare o aggiornare dati esistenti all'interno di una tabella.</li>
<li><em>Cancellazione dei dati (DELETE)</em>: La DML consente di rimuovere dati da una tabella, sia in base a condizioni specifiche che per eliminare tutti i dati.</li>
<li><em>Interrogazione dei dati (SELECT)</em></li>
</ul>

<h2>Selezione dei dati</h2>

<h3>SELECT statement</h3>

<h4>Tutte colonne</h4>

<p>Verranno mostrate <strong>tutte colonne</strong> di una specifica tabella
<code>sql
SELECT *
FROM nome_tabella;
</code></p>

<h4>Colonne specifiche</h4>

<p>Verranno mostrate solo le <strong>colonne selezionate</strong> (colonna1 e colonna2)
<code>sql
SELECT 
    colonna1,
    colonna2
FROM nome_tabella;
</code></p>

<h4>Colonne con alias</h4>

<p>Possiamo assegnare dei nomi pi√π comprensibili utilizzando <strong>AS</strong>, in questo caso colonna1 verr√† mostrata con il "Nome" e la colonna2 con il "Cognome"</p>

<blockquote>
  <p><strong>Note</strong>\
Si pu√≤ anche omettere il AS, funzioner√† ugualmente</p>
</blockquote>

<p><code>sql
SELECT
    colonna1 AS Nome,
    colonna2 AS Cognome
FROM nome_tabella;
</code></p>

<p>In questa query:
* <code>Orders AS o</code> assegna l'alias <code>o</code> alla tabella <code>Orders</code>
* <code>Customers AS c</code> assegna l'alias <code>c</code> alla tabella <code>Customers</code>
* <code>Products AS p</code> assegna l'alias <code>p</code> alla tabella <code>Products</code></p>

<p><code>sql
SELECT
    o.OrderID,
    c.CustomerName,
    p.ProductName,
    o.Quantity
FROM
    Orders AS o
INNER JOIN
    Customers AS c ON o.CustomerID = c.CustomerID
INNER JOIN
    Products AS p ON o.ProductID = p.ProductID;
</code></p>

<h4>Colonne con espressioni aritmetiche</h4>

<p>Possiamo mostrare delle colonne che effettuando dei calcoli aritmetici, molto utili poich√© non ce bisogno di creare colonne inutili!
Espressioni supportate: + - / * %
<code>sql
SELECT 
    colonna1,
    (colonna2 * 2) AS 'Doppio valore' -- spazio? mettici le ' o "
FROM nome_tabella;
</code></p>

<h4>Seleziona dati univoci</h4>

<p>Verranno ignorati i valori ripetuti
<code>sql
SELECT DISTINCT colonna1
FROM nome_tabella;
</code></p>

<p><a href="#Contenuti"><code>üîº</code></a>
<br>
<br></p>

<h3>Filtraggio dei dati</h3>

<h4>Corrispondenze parziali o pattern</h4>

<p>Questa query seleziona i nomi dei clienti che iniziano con "Jo".
<code>sql
SELECT
    Nome
FROM Clienti
WHERE Nome LIKE 'Jo%';
</code></p>

<p>Questa query selezioner√† i nomi dei clienti che terminano con la sequenza "son".
<code>sql
SELECT
    Nome
FROM Clienti
WHERE Nome LIKE '%son';
</code></p>

<p>Questa query selezioner√† i titoli dei libri che contengono la parola "avventura" ovunque nel titolo.
<code>sql
SELECT
    Titolo
FROM Libri 
WHERE Titolo LIKE '%avventura%';
</code></p>

<p>Questa query selezioner√† le parole che hanno tre lettere, dove il carattere mancante pu√≤ essere qualsiasi lettera. Ad esempio, potrebbe corrispondere a "cat", "cot", "cut", ecc.
<code>sql
SELECT
    Parola
FROM Dizionario
WHERE Parola LIKE 'c_t';
</code></p>

<h4>Valore specifico in una colonna</h4>

<p>Questa query seleziona tutti gli ordini in cui il prodotto √® specificamente "Computer".
<code>sql
SELECT
    Prodotto
FROM Ordini
WHERE Prodotto = 'Computer';
</code></p>

<h4>Valore NULL o non NULL</h4>

<p>Questa query seleziona i nomi dei clienti che non hanno un indirizzo specificato, ovvero il valore della colonna "Indirizzo" √® NULL.</p>

<p>L'operatore IS NULL viene utilizzato per verificare se un valore √® nullo.
<code>sql
SELECT
    Nome
FROM Clienti
WHERE Indirizzo IS NULL;
</code>
Questa query selezioner√† tutti i record dalla tabella "Prodotti" in cui il valore nella colonna "Descrizione" non √® nullo. 
<code>sql
SELECT *
FROM Prodotti
WHERE Descrizione IS NOT NULL;
</code></p>

<h4>Filtrare utilizzando una lista dei valori</h4>

<p>Questa query seleziona tutti gli ordini in cui il prodotto √® uno dei valori elencati nella lista (Libro, Computer, Cuffie). </p>

<p>L'operatore IN permette di filtrare i risultati in base a una lista di valori specifici.
<code>sql
SELECT
    Prodotto
FROM Ordini 
WHERE Prodotto IN ('Libro', 'Computer', 'Cuffie');
</code></p>

<p><a href="#Contenuti"><code>üîº</code></a>
<br>
<br></p>

<h3>Operatori di confronto</h3>

<h4>Ugualianza</h4>

<p>Questa query selezioner√† i nomi dei clienti che hanno la citt√† di residenza uguale a "Roma". </p>

<p>L'operatore = viene utilizzato per confrontare i valori in modo esatto.
<code>sql
SELECT
    Nome
FROM Clienti
WHERE Citt√† = 'Roma';
</code></p>

<h4>Disugualianza</h4>

<p>Questa query selezioner√† i prodotti nel magazzino che hanno una quantit√† diversa da zero. </p>

<p>Gli operatori &lt;> o != indicano che il valore nella colonna "Quantit√†" √® diverso da zero.
<code>sql
SELECT
    Prodotto
FROM Magazzino 
WHERE Quantit√† &lt;&gt; 0;
</code></p>

<h4>Maggiore di</h4>

<p>Questa query selezioner√† i nomi e le et√† degli studenti che hanno un'et√† superiore a 18 anni. </p>

<p>L'operatore > indica che il valore nella colonna "Et√†" deve essere maggiore di 18.
<code>sql
SELECT
    Nome,
    Et√†
FROM Studenti
WHERE Et√† &gt; 18;
</code></p>

<h4>Maggiore o uguale di</h4>

<p>Questa query selezioner√† i nomi degli studenti e i voti degli esami in cui il voto √® uguale o maggiore di 60. </p>

<p>L'operatore >= indica che il valore nella colonna "Voto" deve essere 60 o superiore.
<code>sql
SELECT
    Nome,
    Voto
FROM Esami
WHERE Voto &gt;= 60;
</code></p>

<h4>Minore</h4>

<p>Questa query selezioner√† i nomi dei dipendenti con uno stipendio inferiore a 30.000 unit√† monetarie. </p>

<p>L'operatore &lt; indica che il valore nella colonna "Stipendio" deve essere inferiore a 30.000.
<code>sql
SELECT
    Nome
FROM Dipendenti
WHERE Stipendio &lt; 30000;
</code></p>

<h4>Minore o uguale di</h4>

<p>Questa query selezioner√† i nomi degli atleti e i punteggi in cui il punteggio √® uguale o inferiore a 100. </p>

<p>L'operatore &lt;= indica che il valore nella colonna "Punteggio" deve essere 100 o inferiore.
<code>sql
SELECT
    Nome,
    Punteggio
FROM Atleti
WHERE Punteggio &lt;= 100;
</code></p>

<p><a href="#Contenuti"><code>üîº</code></a>
<br>
<br></p>

<h3>Operatori logici</h3>

<h4>AND</h4>

<p>Questa query selezioner√† i nomi dei dipendenti che lavorano nel reparto "Vendite" e hanno uno stipendio superiore a 30.000 unit√† monetarie.</p>

<p>L'operatore AND combina due condizioni e richiede che entrambe siano vere per selezionare una riga.
<code>sql
SELECT
    Nome
FROM Dipendenti 
WHERE Reparto = 'Vendite' AND Stipendio &gt; 30000;
</code>
<!-- <details>
    <summary><b>Demostrazione</b></summary>
    <p>...</p>
    <table>
        <tr>
            <th>Nome</th>
            <th>Reparto</th>
            <th>Stipendio</th>
        </tr>
        <tr>
            <td>Mario</td>
            <td>Vendite</td>
            <td>35000</td>
        </tr>
        <tr>
            <td>Laura</td>
            <td>Vendite</td>
            <td>28000</td>
        </tr>
        <tr>
            <td>Luigi</td>
            <td>Logistica</td>
            <td>32000</td>
        </tr>
    </table>
    <p>Risultato:</p>
    <table>
        <tr>
            <th>Nome</th>
        </tr>
        <tr>
            <td>Mario</td>
        </tr>
    </table>
</details> --></p>

<h4>OR</h4>

<p>Questa query selezioner√† i nomi dei clienti che appartengono alla categoria "VIP" o alla categoria "Nuovi Clienti". </p>

<p>L'operatore OR consente di selezionare le righe che soddisfano almeno una delle condizioni.
<code>sql
SELECT
    Nome
FROM Clienti
WHERE Categoria = 'VIP' OR Categoria = 'Nuovi Clienti';
</code>
<!-- <details>
    <summary><b>Demostrazione</b></summary>
    <p>...</p>
    <table>
        <tr>
            <th>Nome</th>
            <th>Categoria</th>
        </tr>
        <tr>
            <td>Anna</td>
            <td>VIP</td>
        </tr>
        <tr>
            <td>Giovanni</td>
            <td>Standard</td>
        </tr>
        <tr>
            <td>Luca</td>
            <td>Nuovi Clienti</td>
        </tr>
    </table>
    <p>Risultato:</p>
    <table>
        <tr>
            <th>Nome</th>
        </tr>
        <tr>
            <td>Anna</td>
        </tr>
        <tr>
            <td>Luca</td>
        </tr>
    </table>
</details> --></p>

<h4>AND e OR</h4>

<p>Questa query selezioner√† i nomi dei prodotti che appartengono alle categorie "Elettronica" o "Informatica" e hanno un prezzo superiore a 500 unit√† monetarie. </p>

<p>Le parentesi sono utilizzate per definire le priorit√† delle condizioni.
<code>sql
SELECT
    Nome
FROM Prodotti
WHERE (Categoria = 'Elettronica' OR Categoria = 'Informatica') AND Prezzo &gt; 500;
</code>
<!-- <details>
    <summary><b>Demostrazione</b></summary>
    <p>...</p>
    <table>
        <tr>
            <th>Nome</th>
            <th>Categoria</th>
            <th>Prezzo</th>
        </tr>
        <tr>
            <td>Prodotto A</td>
            <td>Elettronica</td>
            <td>550</td>
        </tr>
        <tr>
            <td>Prodotto B</td>
            <td>Informatica</td>
            <td>450</td>
        </tr>
        <tr>
            <td>Prodotto C</td>
            <td>Elettronica</td>
            <td>480</td>
        </tr>
    </table>
    <p>Risultato:</p>
    <table>
        <tr>
            <th>Nome</th>
        </tr>
        <tr>
            <td>Prodotto A</td>
        </tr>
    </table> <br />
</details> --></p>

<h4>NOT</h4>

<p>Questa query selezioner√† i titoli dei libri che non appartengono al genere "Fantascienza". </p>

<p>L'operatore NOT nega una condizione, selezionando le righe che non la soddisfano.
<code>sql
SELECT
    Titolo
FROM Libri
WHERE NOT Genere = 'Fantascienza';
</code>
<!-- <details>
    <summary><b>Demostrazione</b></summary>
    <p>...</p>
    <table>
        <tr>
            <th>Titolo</th>
            <th>Genere</th>
        </tr>
        <tr>
            <td>Libro 1</td>
            <td>Fantascienza</td>
        </tr>
        <tr>
            <td>Libro 2</td>
            <td>Fantasy</td>
        </tr>
        <tr>
            <td>Libro 3</td>
            <td>Romanzo</td>
        </tr>
    </table>
    <p>Risultato:</p>
    <table>
        <tr>
            <th>Titolo</th>
        </tr>
        <tr>
            <td>Libro 2</td>
        </tr>
        <tr>
            <td>Libro 3</td>
        </tr>
    </table>
</details> --></p>

<p><a href="#Contenuti"><code>üîº</code></a>
<br>
<br></p>

<h3>Ordinamento dei risultati</h3>

<h4>Ordinamento crescente per una colonna</h4>

<p>Questa query selezioner√† i nomi e le et√† degli studenti e li ordiner√† in modo crescente in base all'et√†.</p>

<p>Il risultato mostrer√† gli studenti dall'et√† pi√π bassa alla pi√π alta.</p>

<blockquote>
  <p><strong>Note</strong>\
Se non specifici alcun tipo di ordinamento (n√© ASC n√© DESC), l'ordinamento di base sar√† in modo ascendente (ASC).
<code>sql
SELECT
    Nome,
    Et√†
FROM Studenti
ORDER BY Et√†;
</code></p>

<h4>Ordinamento decrescente per una colonna</h4>
</blockquote>

<p>Questa query selezioner√† i prodotti e i loro prezzi e li ordiner√† in modo decrescente in base al prezzo.</p>

<p>Il risultato mostrer√† i prodotti con il prezzo pi√π alto prima.
<code>sql
SELECT
    Prodotto,
    Prezzo
FROM Prodotti
ORDER BY Prezzo DESC;
</code></p>

<h4>Ordinamento per pi√π colonne</h4>

<p>Questa query selezioner√† i nomi, i cognomi e i punteggi degli studenti e li ordiner√† in modo decrescente in base al punteggio e poi in modo crescente in base al cognome. </p>

<blockquote>
  <p><strong>Note</strong>\
Gli studenti con punteggi pi√π alti verranno mostrati per primi, e in caso di punteggi uguali, verranno ordinati in base al cognome in ordine alfabetico crescente.
<code>sql
SELECT
    Nome,
    Cognome,
    Punteggio
FROM Studenti
ORDER BY Punteggio DESC, Cognome ASC;
</code></p>

<h4>Ordinamento con espressioni aritmetiche</h4>
</blockquote>

<p>Questa query selezioner√† i nomi e gli stipendi annuali calcolati moltiplicando lo stipendio mensile per 12.</p>

<p>I risultati verranno ordinati in modo decrescente in base allo stipendio annuale.
<code>sql
SELECT
    Nome,
    Stipendio * 12 AS StipendioAnnuale
FROM Dipendenti
ORDER BY StipendioAnnuale DESC;
</code>
<a href="#Contenuti"><code>üîº</code></a>
<br>
<br></p>

<h3>Limitazione dei risultati</h3>

<h4>Limitazione del numero di righe restituite</h4>

<p>Questa query restituir√† i nomi e i cognomi dei primi 5 clienti nella tabella "Clienti".</p>

<p>La clausola LIMIT viene utilizzata per limitare il numero di righe restituite ai primi 5 risultati.
<code>sql
SELECT
    Nome,
    Cognome
FROM Clienti LIMIT 5;
</code>
<!-- <details>
    <summary><b>Demostrazione</b></summary>
    <p>...</p>
    <table>
        <tr>
            <th>Nome</th>
            <th>Cognome</th>
        </tr>
        <tr>
            <td>John</td>
            <td>Doe</td>
        </tr></p>

<pre><code>&lt;/table&gt;
&lt;p&gt;Risultato:&lt;/p&gt;
&lt;table&gt;
    &lt;tr&gt;
        &lt;th&gt;Nome&lt;/th&gt;
        &lt;th&gt;Cognome&lt;/th&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;John&lt;/td&gt;
        &lt;td&gt;Doe&lt;/td&gt;
    &lt;/tr&gt;

&lt;/table&gt;
</code></pre>

<p></details> --></p>

<h4>Limitazione dei risultati con ordinamento</h4>

<p>Questa query selezioner√† i nomi e i prezzi dei primi 3 prodotti ordinati in modo decrescente in base al prezzo.</p>

<p>La combinazione di ORDER BY e LIMIT consente di ottenere i primi N risultati dell'ordinamento desiderato.
<code>sql
SELECT
    Prodotto,
    Prezzo
FROM Prodotti
ORDER BY Prezzo DESC LIMIT 3;
</code>
<!-- <details>
    <summary><b>Demostrazione</b></summary>
    <p>...</p>
    <table>
        <tr>
            <th>Prodotto</th>
            <th>Prezzo</th>
        </tr>
        <tr>
            <td>Prodotto A</td>
            <td>100</td>
        </tr>
        <i> Altri dati della tabella Prodotti ordinati per Prezzo </i>
        <i> ... </i>
    </table>
    <p>Risultato:</p>
    <table>
        <tr>
            <th>Prodotto</th>
            <th>Prezzo</th>
        </tr>
        <tr>
            <td>Prodotto C</td>
            <td>80</td>
        </tr>
        <i> Altri 2 risultati della tabella Prodotti ordinati per Prezzo </i>
        <i> ... </i>
    </table>
</details> --></p>

<h4>Limitazione dei risultati con offset</h4>

<p>Questa query restituir√† i nomi e i cognomi dei dipendenti a partire dal sesto (offset di 5) fino al decimo (5 risultati successivi).</p>

<p>L'istruzione OFFSET specifica da quale posizione iniziare a restituire i risultati.
<code>sql
SELECT
    Nome,
    Cognome
FROM Dipendenti LIMIT 5 OFFSET 5;
</code>
<!-- <details>
    <summary><b>Demostrazione</b></summary>
    <p>...</p>
    <table>
        <tr>
            <th>Nome</th>
            <th>Cognome</th>
        </tr>
        <i> Dati della tabella Dipendenti </i>
        <i> ... </i>
    </table>
    <p>Risultato:</p>
    <table>
        <tr>
            <th>Nome</th>
            <th>Cognome</th>
        </tr>
        <tr>
            <td>Emily</td>
            <td>Johnson</td>
        </tr>
        <i> Altri 4 risultati della tabella Dipendenti (dal sesto al decimo) </i>
        <i> ... </i>
    </table>
</details>  --></p>

<h4>Limitazione dei risultati con combinazione di offset e limit</h4>

<p>Questa query restituir√† i titoli dei libri a partire dal 21simo (offset di 20) fino al trentesimo (10 risultati successivi).</p>

<p>La combinazione di LIMIT e OFFSET consente di recuperare porzioni specifiche di dati.
<code>sql
SELECT
    Titolo
FROM Libri LIMIT 10 OFFSET 20;
</code>
<!-- <details>
    <summary><b>Demostrazione</b></summary>
    <p>...</p>
    <table>
        <tr>
            <th>Titolo</th>
        </tr>
        <i>Dati della tabella Libri</i>
        <i> ... </i>
    </table>
    <p>Risultato:</p>
    <table>
        <tr>
            <th>Titolo</th>
        </tr>
        <tr>
            <td>Libro 21</td>
        </tr>
        <i> Altri 9 risultati della tabella Libri (dal ventunesimo al trentesimo) </i>
        <i> ... </i>
    </table>
</details> --></p>

<p><a href="#Contenuti"><code>üîº</code></a>
<br>
<br></p>

<h3>Operatori di aggregazione</h3>

<h4>Sommare i valori</h4>

<p>Questa query calcola la somma di tutti i valori nella colonna "Quantita" della tabella "Ordini" e restituisce il risultato con il nome "TotaleQuantita".
<code>sql
SELECT
    SUM(Quantita) AS TotaleQuantita
FROM Ordini;
</code></p>

<h5>Sommare i valori per ciascun gruppo</h5>

<p>Questa query calcola la somma delle quantit√† di prodotti per ciascuna categoria nella tabella "Prodotti".
<code>sql
SELECT
    Categoria,
    SUM(Quantita) AS TotaleQuantita
FROM Prodotti
GROUP BY Categoria;
</code></p>

<h4>Calcolare la media</h4>

<p>Questa query calcola la media dei valori nella colonna "Prezzo" della tabella "Prodotti" e restituisce il risultato con il nome "MediaPrezzo".
<code>sql
SELECT
    AVG(Prezzo) AS MediaPrezzo
FROM Prodotti;
</code></p>

<h5>Calcolare la media condizionale</h5>

<p>Questa query calcola la media dei punteggi degli esami superiori a 70 per ciascun anno nella tabella "Esami".
<code>sql
SELECT
    Anno,
    AVG(CASE WHEN Punteggio &gt; 70 THEN Punteggio ELSE NULL END) AS MediaSuperiori70
FROM Esami
GROUP BY Anno;
</code></p>

<h5>Calcolare la media ponderata</h5>

<p>Questa query calcola la media ponderata dei punteggi degli studenti nella tabella "Voti", considerando il peso di ciascun voto.
<code>sql
SELECT
    Studente,
    AVG(Punteggio * Peso / 100) AS MediaPonderata
FROM Voti
GROUP BY Studente;
</code></p>

<h4>Contare</h4>

<p>Questa query conta il numero totale di righe nella tabella "Clienti" e restituisce il risultato con il nome "NumeroClienti".
<code>sql
SELECT
    COUNT(*) AS NumeroClienti
FROM Clienti;
</code></p>

<h5>Contare valori distinti</h5>

<p>Questa query conta il numero di categorie distinte nella tabella "Prodotti".
<code>sql
SELECT
    COUNT(DISTINCT Categoria) AS NumeroCategorie
FROM Prodotti;
</code></p>

<h4>Valore massimo</h4>

<p>Questa query restituisce il valore massimo nella colonna "Punteggio" della tabella "Studenti" con il nome "PunteggioMassimo".
<code>sql
SELECT
    MAX(Punteggio) AS PunteggioMassimo
FROM Studenti;
</code></p>

<h5>Valore massimo per ciascun gruppo</h5>

<p>Questa query restituisce il massimo stipendio per ciascun dipartimento nella tabella "Dipendenti".
<code>sql
SELECT
    Dipartimento,
    MAX(Stipendio) AS StipendioMassimo
FROM Dipendenti
GROUP BY Dipartimento;
</code></p>

<h4>Valore minimo</h4>

<p>Questa query restituisce il valore minimo nella colonna "Quantita" della tabella "Magazzino" con il nome "QuantitaMinima".
<code>sql
SELECT
    MIN(Quantita) AS QuantitaMinima
FROM Magazzino;
</code></p>

<h5>Valore minimo condizionale</h5>

<p>Questa query restituisce il voto minimo positivo per ciascun anno nella tabella "Esami".
<code>sql
SELECT Anno,
    MIN(CASE WHEN Voto &gt; 0 THEN Voto ELSE NULL END) AS VotoMinimoPositivo
FROM Esami
GROUP BY Anno;
</code></p>

<h4>Arrotondamento</h4>

<p>Questa query calcola la media dei voti nella colonna "MediaVoti" della tabella "Esami" e restituisce il risultato arrotondato a due decimali con il nome "MediaVotiArrotondata".
<code>sql
SELECT
    ROUND(MediaVoti, 2) AS MediaVotiArrotondata
FROM Esami;
</code></p>

<p><a href="#Contenuti"><code>üîº</code></a>
<br>
<br></p>

<h3>Join</h3>

<p>In SQL, un "JOIN" √® un metodo per combinare righe provenienti da due o pi√π tabelle, basato su una colonna correlata tra di loro. Ci sono diversi tipi di JOIN in SQL:</p>

<ul>
<li><strong>INNER JOIN</strong>: Restituisce le righe quando c'√® una corrispondenza in entrambe le tabelle.</li>
<li><strong>LEFT JOIN</strong>: Restituisce tutte le righe dalla tabella di sinistra, e le righe corrispondenti dalla tabella di destra. Se non c'√® corrispondenza, il risultato √® NULL sulla parte destra.</li>
<li><strong>RIGHT JOIN</strong>: Restituisce tutte le righe dalla tabella di destra, e le righe corrispondenti dalla tabella di sinistra. Se non c'√® corrispondenza, il risultato √® NULL sulla parte sinistra.</li>
<li><strong>FULL JOIN</strong>: Restituisce le righe quando c'√® una corrispondenza in una delle tabelle. Quindi, se c'√® una riga in una delle tabelle che non corrisponde con l'altra, il risultato sar√† NULL.</li>
</ul>

<h4>INNER JOIN</h4>

<p>La tabella <code>Orders</code>:</p>

<p>| OrderID | CustomerID | OrderDate |
|---------|------------|-----------|
| 1       | 3          | 2022-01-22|
| 2       | 1          | 2022-03-20|
| 3       | 2          | 2022-04-22|
| 4       | 4          | 2022-02-10|</p>

<p>La tabella <code>Customers</code>:</p>

<p>| CustomerID | CustomerName |
|------------|--------------|
| 1          | John Doe     |
| 2          | Jane Doe     |
| 3          | Alice        |
| 4          | Bob          |</p>

<p>Se desideri combinare queste due tabelle per ottenere un elenco di ordini con il nome del cliente, puoi utilizzare un INNER JOIN. La query SQL sarebbe la seguente:</p>

<p><code>sql
SELECT Orders.OrderID, Customers.CustomerName, Orders.OrderDate
FROM Orders
INNER JOIN Customers ON Orders.CustomerID = Customers.CustomerID;
</code></p>

<p>Questa istruzione restituir√† una tabella che include solo gli ordini per i quali esiste un cliente corrispondente:</p>

<p>| OrderID | CustomerName | OrderDate |
|---------|--------------|-----------|
| 1       | Alice        | 2022-01-22|
| 2       | John Doe     | 2022-03-20|
| 3       | Jane Doe     | 2022-04-22|
| 4       | Bob          | 2022-02-10|</p>

<h4>LEFT JOIN</h4>

<p>La tabella <code>Orders</code>:</p>

<p>| OrderID | CustomerID | OrderDate |
|---------|------------|-----------|
| 1       | 3          | 2022-01-22|
| 2       | 1          | 2022-03-20|
| 3       | 2          | 2022-04-22|
| 4       | 5          | 2022-02-10|</p>

<p>La tabella <code>Customers</code>:</p>

<p>| CustomerID | CustomerName |
|------------|--------------|
| 1          | John Doe     |
| 2          | Jane Doe     |
| 3          | Alice        |</p>

<p>Se desideri combinare queste due tabelle per ottenere un elenco di ordini con il nome del cliente, puoi utilizzare un LEFT JOIN. La query SQL sarebbe la seguente:</p>

<p><code>sql
SELECT Orders.OrderID, Customers.CustomerName, Orders.OrderDate
FROM Orders
LEFT JOIN Customers ON Orders.CustomerID = Customers.CustomerID;
</code></p>

<p>Questa istruzione restituir√† una tabella che include tutti gli ordini, ma i nomi dei clienti appariranno solo per gli ordini in cui esiste un cliente corrispondente. Se un ordine ha un <code>CustomerID</code> che non esiste nella tabella <code>Customers</code>, il <code>CustomerName</code> per quel determinato ordine sar√† NULL.</p>

<p>| OrderID | CustomerName | OrderDate |
|---------|--------------|-----------|
| 1       | Alice        | 2022-01-22|
| 2       | John Doe     | 2022-03-20|
| 3       | Jane Doe     | 2022-04-22|
| 4       | NULL         | 2022-02-10|</p>

<h4>RIGHT JOIN</h4>

<p>La tabella <code>Orders</code>:</p>

<p>| OrderID | CustomerID | OrderDate |
|---------|------------|-----------|
| 1       | 3          | 2022-01-22|
| 2       | 1          | 2022-03-20|
| 3       | 2          | 2022-04-22|</p>

<p>La tabella <code>Customers</code>:</p>

<p>| CustomerID | CustomerName |
|------------|--------------|
| 1          | John Doe     |
| 2          | Jane Doe     |
| 3          | Alice        |
| 4          | Bob          |</p>

<p>Se desideri combinare queste due tabelle per ottenere un elenco di clienti con i relativi ordini, puoi utilizzare un RIGHT JOIN. La query SQL sarebbe la seguente:</p>

<p><code>sql
SELECT Orders.OrderID, Customers.CustomerName, Orders.OrderDate
FROM Orders
RIGHT JOIN Customers ON Orders.CustomerID = Customers.CustomerID;
</code></p>

<p>Questa istruzione restituir√† una tabella che include tutti i clienti, ma gli ordini appariranno solo per i clienti in cui esiste un ordine corrispondente. Se un cliente non ha nessun ordine nella tabella <code>Orders</code>, l'<code>OrderID</code> e l'<code>OrderDate</code> per quel cliente saranno NULL.</p>

<p>| OrderID | CustomerName | OrderDate |
|---------|--------------|-----------|
| 1       | Alice        | 2022-01-22|
| 2       | John Doe     | 2022-03-20|
| 3       | Jane Doe     | 2022-04-22|
| NULL    | Bob          | NULL      |</p>

<h4>FULL JOIN</h4>

<p>La tabella <code>Orders</code>:</p>

<p>| OrderID | CustomerID | OrderDate |
|---------|------------|-----------|
| 1       | 3          | 2022-01-22|
| 2       | 1          | 2022-03-20|
| 3       | 2          | 2022-04-22|
| 4       | 5          | 2022-02-10|</p>

<p>La tabella <code>Customers</code>:</p>

<p>| CustomerID | CustomerName |
|------------|--------------|
| 1          | John Doe     |
| 2          | Jane Doe     |
| 3          | Alice        |
| 4          | Bob          |</p>

<p>Se vuoi combinare queste due tabelle per ottenere un elenco di tutti gli ordini e tutti i clienti, puoi utilizzare un FULL JOIN. La query SQL sarebbe la seguente:</p>

<p><code>sql
SELECT Orders.OrderID, Customers.CustomerName, Orders.OrderDate
FROM Orders
FULL JOIN Customers ON Orders.CustomerID = Customers.CustomerID;
</code></p>

<p>Questa istruzione restituir√† una tabella che include tutti gli ordini e tutti i clienti. Se un ordine ha un <code>CustomerID</code> che non esiste nella tabella <code>Customers</code>, il <code>CustomerName</code> per quel determinato ordine sar√† NULL. Allo stesso modo, se un cliente non ha nessun ordine nella tabella <code>Orders</code>, l'<code>OrderID</code> e l'<code>OrderDate</code> per quel cliente saranno NULL.</p>

<p>| OrderID | CustomerName | OrderDate |
|---------|--------------|-----------|
| 1       | Alice        | 2022-01-22|
| 2       | John Doe     | 2022-03-20|
| 3       | Jane Doe     | 2022-04-22|
| 4       | NULL         | 2022-02-10|
| NULL    | Bob          | NULL      |</p>

<h3>Unione implicita</h3>

<p><details>
  <summary><b>Spiegazione</b></summary></p>

<p>Questa query SQL seleziona dati da due tabelle: <code>Orders</code> e <code>Customers</code>. L'obiettivo √® ottenere una lista di ordini insieme ai nomi dei clienti che hanno effettuato tali ordini.</p>

<p>Ecco una spiegazione dettagliata di ciascuna parte della query:</p>

<ul>
<li><p><code>SELECT Orders.OrderID, Customers.CustomerName</code>: Questa parte della query specifica quali colonne di dati si desidera ottenere nel risultato. In questo caso, si desidera ottenere l'<code>OrderID</code> dalla tabella <code>Orders</code> e il <code>CustomerName</code> dalla tabella <code>Customers</code>.</p></li>
<li><p><code>FROM Orders, Customers</code>: Questa parte della query specifica da quali tabelle si desidera ottenere i dati. In questo caso, si desidera ottenere i dati dalle tabelle <code>Orders</code> e <code>Customers</code>.</p></li>
<li><p><code>WHERE Orders.CustomerID = Customers.CustomerID</code>: Questa √® la clausola <code>WHERE</code> che stabilisce la condizione per unire le tabelle. In questo caso, le tabelle <code>Orders</code> e <code>Customers</code> vengono unite sulla base del <code>CustomerID</code>. Questo significa che per ogni riga nella tabella <code>Orders</code>, la query cerca una riga corrispondente nella tabella <code>Customers</code> dove <code>CustomerID</code> √® lo stesso. In altre parole, per ogni ordine, la query trova il cliente che ha effettuato quell'ordine.</p>

<p>Il risultato di questa query sar√† un set di righe con <code>OrderID</code> e <code>CustomerName</code>, dove ogni riga rappresenta un ordine e il cliente che ha effettuato quell'ordine.
</details></p></li>
</ul>

<p><code>sql
SELECT Orders.OrderID, Customers.CustomerName
FROM Orders, Customers
WHERE Orders.CustomerID = Customers.CustomerID;
</code>
<a href="#Contenuti"><code>üîº</code></a>
<br>
<br></p>

<h3>Subquery</h3>

<p>Una subquery, o sottoquery, √® una query SQL che √® <strong>incorporata all'interno di un'altra query</strong>. Una subquery pu√≤ restituire dati a un comando SQL esterno, o pu√≤ essere eseguita come un comando autonomo. Le subquery possono essere utilizzate in diverse istruzioni SQL come <code>SELECT</code>, <code>INSERT</code>, <code>UPDATE</code>, o <code>DELETE</code>.</p>

<h4>Che restituiscono un valore</h4>

<p>Una subquery che restituisce un valore √® una subquery che restituisce un singolo valore. Questo tipo di subquery pu√≤ essere utilizzato ovunque ci si aspetti un singolo valore, come in un'istruzione <code>SELECT</code>, <code>WHERE</code> o <code>HAVING</code>.</p>

<p>In questo esempio, la subquery <code>(SELECT AVG(punteggio) FROM studenti)</code> calcola il punteggio medio degli studenti. La query <strong>esterna</strong> poi seleziona i nomi e i punteggi degli studenti che hanno un punteggio superiore alla media.</p>

<p><code>sql
SELECT nome, punteggio 
FROM studenti 
WHERE punteggio &gt; (SELECT AVG(punteggio) FROM studenti);
</code>
<details>
  <summary><b>Spiegazione</b></summary>
    <ol>
        <li><p> La subquery <code>(SELECT AVG(punteggio) FROM studenti)</code> viene eseguita per prima. Questa subquery calcola il punteggio medio di tutti gli studenti nella tabella studenti.</p></li>
        <li><p> Il risultato della subquery (il punteggio medio) viene poi utilizzato nella clausola <code>WHERE</code> della query esterna.</p></li>
        <li><p>La query esterna <code>SELECT nome, punteggio FROM studenti WHERE punteggio > ...</code> viene quindi eseguita. Questa query seleziona le colonne  <code>nome</code> e <code>punteggio</code> dalla tabella <code>studenti</code>, ma solo per le righe in cui il <code>punteggio</code> √® maggiore del punteggio medio calcolato dalla subquery.</p></li> <br />
    </ol></p>

<p></details></p>

<h5>MAX</h5>

<p>```sql</p>

<p>```</p>

<h5>AVG</h5>

<p>```sql</p>

<p>```</p>

<h3>Subquery che restituiscono pi√π valori</h3>

<h4>IN</h4>

<h4>NOT IN</h4>

<h4>ANY</h4>

<h4>ALL</h4>

<h4>EXIT</h4>

<h4>NOT EXIT</h4>

<h3>Query correlate</h3>

<h3>Subquery nella FROM</h3>

<p><a href="#Contenuti"><code>üîº</code></a>
<br>
<br></p>

<p><hr>
fatto da me, GitHub Copilot e ChatGPT.</p>
